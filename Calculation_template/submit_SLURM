#!/bin/bash

#SBATCH --job-name=___
#SBATCH --nodes=___
#SBATCH --ntasks=___
#SBATCH --ntasks-per-node=___
#SBATCH --time=7-24:00:00
#SBATCH --partition=___
#SBATCH --mem-per-cpu=___

export OMP_NUM_THREADS=$SLURM_NTASKS_PER_NODE
ulimit -c 0




################################################################################
#                                 USER SETTINGS                                #
################################################################################
#----------------------------------COMPULSORY----------------------------------#
GENMAT=/path/to/GenericMaterial

PATH_INPUT=GWinput
PATH_DATA=Results

START_IT=___
END_IT=___

EXE_SC=SelfConsistency
EXE_QMC=ct_hyb
EXE_AKW=Akw_builder

#-----------------------------------OPTIONAL-----------------------------------#
PATH_INPUT_TR=GWinput_beta___
####SKIP_FIRST_SC="T"
####SKIP_FIRST_COLLECT="T"
####SKIP_ALL_QMC="T"
####CHANGE_BETA_IT=1
####COLLECT_AKW="T"
####TO BE REMOVED:
####REPLACE_QMC_RES="T"
####PREP_MAXENT="T"




################################################################################
#                             AUTO-SETUP SETTINGS                              #
################################################################################
LOCAL=$(pwd)
BINqmc=${GENMAT}/Solver/bin
BINsc=${GENMAT}/SelfConsistency/bin

if [ -z ${PATH_INPUT_TR+x}      ]; then PATH_INPUT_TR=${PATH_INPUT} ; fi
if [ -z ${SKIP_FIRST_SC+x}      ]; then SKIP_FIRST_SC="F"           ; fi
if [ -z ${SKIP_FIRST_COLLECT+x} ]; then SKIP_FIRST_COLLECT="F"      ; fi
if [ -z ${SKIP_ALL_QMC+x}       ]; then SKIP_ALL_QMC="F"            ; fi
if [ -z ${COLLECT_AKW+x}        ]; then COLLECT_AKW="F"             ; fi
if [ -z ${REPLACE_QMC_RES+x}    ]; then REPLACE_QMC_RES="F"         ; fi
if [ -z ${PREP_MAXENT+x}        ]; then PREP_MAXENT="F"             ; fi

export l0=`grep -n "PATH_INPUT=" input.in    | awk -F  ":" '{print $1}'`
export l1=`grep -n "PATH_INPUT_TR=" input.in | awk -F  ":" '{print $1}'`
export l2=`grep -n "PATH_DATA=" input.in     | awk -F  ":" '{print $1}'`
export l3=`grep -n "START_IT=" input.in      | awk -F  ":" '{print $1}'`
export l4=`grep -n "LAST_IT=" input.in       | awk -F  ":" '{print $1}'`
export l5=`grep -n "MATCH_BETA=" input.in    | awk -F  ":" '{print $1}'`
export l6=`grep -n "COLLECT_QMC=" input.in   | awk -F  ":" '{print $1}'`

sed -i ${l0}'s/'"PATH_INPUT=.*!"'/'"PATH_INPUT=${PATH_INPUT}           !"'/' input.in
sed -i ${l1}'s/'"PATH_INPUT_TR=.*!"'/'"PATH_INPUT_TR=${PATH_INPUT_TR}  !"'/' input.in
sed -i ${l2}'s/'"PATH_DATA=.*!"'/'"PATH_DATA=${PATH_DATA}              !"'/' input.in
sed -i ${l4}'s/'"LAST_IT=.*!"'/'"LAST_IT=${END_IT}                     !"'/' input.in

if [ "${PREP_MAXENT}" == "T" ] || [ "${COLLECT_AKW}" == "T" ] ; then
   EXE_SC=${EXE_SC}_akw
   SKIP_ALL_QMC="T"
fi




################################################################################
#                             SELF-CONSISTENCY LOOP                            #
################################################################################
for IT in `seq ${START_IT} 1 ${END_IT}`
do

   #
   #
   # Input update
   IT_DATA=${LOCAL}/${PATH_DATA}/${IT}/
   sed -i ${l3}'s/'"START_IT=.*!"'/'"START_IT=${IT}         !"'/' input.in
   sed -i ${l5}'s/'"MATCH_BETA=.*!"'/'"MATCH_BETA=F                                 !"'/' input.in
   sed -i ${l6}'s/'"COLLECT_QMC=.*!"'/'"COLLECT_QMC=T                                !"'/' input.in
   if [ ! -z ${CHANGE_BETA_IT+x} ] && [ ${CHANGE_BETA_IT} == ${IT} ] ; then
      sed -i ${l5}'s/'"MATCH_BETA=.*!"'/'"MATCH_BETA=T                                 !"'/' input.in
   fi
   if [ "${SKIP_FIRST_COLLECT}" == "T" ] && [ ${IT} == ${START_IT} ] ; then
      sed -i ${l6}'s/'"COLLECT_QMC=.*!"'/'"COLLECT_QMC=F                                !"'/' input.in
   fi
   if [ "${PREP_MAXENT}" == "T" ] ; then cp input.in input.in.akw  ; fi
   sleep 2

   #
   #
   # Collect spectral functions and break the loop
   if [ "${COLLECT_AKW}" == "T" ] ; then
      srun --ntasks=1 ${BINsc}/${EXE_AKW} > report_Akw_it${IT} 2> err_Akw_it${IT}
      mv {report_Akw_it${IT},err_Akw_it${IT}} ${IT_DATA}
      break
   fi
   sleep 2

   #
   #
   # Lattice problem
   if [ ${IT} -eq ${START_IT} ] && [ "${SKIP_FIRST_SC}" == "T" ] ; then
      touch doSolver
   else
      srun --ntasks=1 ${BINsc}/${EXE_SC} > report_sc_it${IT} 2> err_sc_it${IT}
      if [ "${PREP_MAXENT}" == "F" ] ; then mv {report_sc_it${IT},err_sc_it${IT}} ${IT_DATA}  ; fi
   fi
   sleep 2

   #
   #
   sed -i  '/NTAU_F_IMP_IN/d' input.in
   sed -i  '/NTAU_B_IMP_IN/d' input.in

   #
   #
   # Impurity problem
   if [ "${SKIP_ALL_QMC}" == "F" ] ; then
      if [ -f "doSolver" ]; then
         rm doSolver
         srun --mpi=pmi2 ${BINqmc}/${EXE_QMC} used.input.in ${IT_DATA} > report_qmc_it${IT} 2> err_qmc_it${IT}
         #mpirun -np $SLURM_NTASKS_PER_NODE ${BINqmc}/${EXE_QMC} used.input.in ${IT_DATA} > report_qmc_it${IT} 2> err_qmc_it${IT}
         mv {report_qmc_it${IT},err_qmc_it${IT}} ${IT_DATA}
      else
         break
      fi
   else
      if [ -f "doSolver" ]; then
         rm doSolver
         if [ "${REPLACE_QMC_RES}" == "T" ]  && [ ${IT} != 0 ] ; then
            IT_PRV=`LC_ALL=en awk "BEGIN{print ${IT}-1 }"`
            rm -r ${IT_DATA}/Solver_*
            cp -r ${LOCAL}/${PATH_DATA}/${IT_PRV}/Solver_* ${IT_DATA}/
         fi
         continue
      else
         break
      fi
   fi
   sleep 2

done
